操作系统：
一、线程同步的几种方式：
1、互斥量（mutex）：成功获取互斥量的线程才能访问数据；其他线程将被挂起，直到当前线程释放了互斥量。
2、信号量（sem）：信号发出时，可以有多个线程去接收这个信号，所以可以控制访问共享资源的线程数量。
3、事件（event）：事件有两种状态，激发状态(signaled or true)或未激发状态(unsignal or false)，当HANDLE hEvent= CreateEvent(NULL, false, true, (LPCTSTR)"event");相当于创建了这个事件，处于激发状态。如果有线程接收这个事件（WaitForSingleObject(hEvent, INFINITE);）然后线程就可以往下执行。多个线程竞争，但是只能有一个线程执行；线程执行完，自动设置为未激发状态，想要再次激活事件的话就需要调用SetEvent(hEvent);再次激活事件。
4、临界区：是指一个访问共享资源的代码段，临界区对象则是指当用户使用某个线程访问共享资源时，必须使代码段独占该资源，不允许其他线程访问该资源。在该线程访问完资源后，其他线程才能对资源进行访问。

可重入函数和不可重入函数
可重入函数：就是这个函数在执行到任何时刻，都可以中断它，转入OS调度下去执行另一段代码，不会发生任何错误；
不可重入函数：就是由于使用了一些系统资源导致它出现中断的话没可能会产生问题；
（使用了全局或者静态数据结构；new，malloc；调用了标准的I/O函数;进行的浮点运算；调用了其他不可重入函数；锁等）
浮点一般都是不可重入的 (浮点运算大多使用协处理器或者软件模拟来实现)
内存模型：
c++内存主要分为5个区域
1、堆区（heap）：由new，malloc动态分配的内存块，由程序员自己释放，如果没有释放，在程序结束时系统会自动回收；
2、栈区（stack）：在编译器需要的时候分配，不需要了就自动释放。如局部变量，函数参数，只在当前函数或者下一层函数中有效，一旦函数返回，就自动释放了；
3、全局静态存储区：全局变量和静态变量的存储区。
4、常量存储区：存放常量，不允许修改；
5、代码区：存放代码（如函数，虚表），不允许修改，可以执行。
内存分段，分页：
如果程序直接访问物理内存的话，对物理内存的操作可能会出现混乱（通过指针偏移，在A进程，操作B进程的内存）。
这样，产生了三个问题；
1、进程地址空间不隔离；2、内存使用效率低；3、程序运行的地址不确定。

为了解决这些问题，操作系统添加了一个虚拟地址的概念，作为中间层。当创建一个进程时，操作系统会给该进程创建一个虚拟的进程地址空间，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上，这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。通过映射机制，当程序访问虚拟地址空间上的某个地址值时，就相当于访问了物理地址空间中的另一个值。
这种分段的映射方法虽然解决了上述中的问题一和问题三，但并没能解决问题二，即内存的使用效率问题。在分段的映射方法中，每次换入换出内存的都是整个程序，这样会造成大量的磁盘访问操作，导致效率低下。所以这种映射方法还是稍显粗糙，粒度比较大。实际上，程序的运行有局部性特点，在某个时间段内，程序只是访问程序的一小部分数据，也就是说，程序的大部分数据在一个时间段内都不会被用到。基于这种情况，人们想到了粒度更小的内存分割和映射方法，这种方法就是分页(Paging)。

分页的基本方法是，将地址空间分成许多的页。
在分段的方法中，每次程序运行时总是把程序全部装入内存，而分页的方法则有所不同。
分页的思想是程序运行时用到哪页就为哪页分配内存，没用到的页暂时保留在硬盘上。当用到这些页时再在物理地址空间中为这些页分配内存，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。分页这个技术，它的虚拟地址空间仍然是连续的，但是，每一页映射后的物理地址就不一定是连续的了。程序的换入换出就可以以页为单位了，粒度更加的小了，效率也就高了。
c++的几种锁：
互斥锁（Mutex）：控制多个线程对共享资源的访问，避免多个线程在某一时刻同时操作一个共享资源，在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前，其他线程都不可以获取该互斥锁，如果其它线程想要获取该互斥锁，就以阻塞的方式进行等待。
自旋锁：互斥锁是sleep-waiting的锁，当互斥锁被占用时，线程进入阻塞状态，线程会被放入等待队列中去，该线程的处理器不会因为线程阻塞而空闲着，去处理其他事务了。
自旋锁是busy-waiting的锁，如果线程想要获取自旋锁，发现被占用，该线程的处理器会一直不断的循环检查锁是否可用，直到获取自旋锁为止；比较耗费cpu。
读写锁：以读方式获取锁，或者写方式获取锁；对数据允许多个读操作同时访问，只允许一个写操作访问。
条件锁：当某线程获取了锁对象，但因为某些条件没有满足，需要在这个条件上等待，直到
条件满足才能够往下继续执行时，就需要用到条件锁。
     这种情况下，线程主动在某条件上阻塞，当其它线程发现条件发生变化时，就可以唤醒阻塞在此条件上的线程。
递归锁：同一个线程在不解锁的情况下，可以多次获取锁定同一个递归锁，而且不会产生死锁，每次获取都会+1次锁次数；其他线程想要获取这个锁的话，就要等待释放所有次数的锁。
如果读写锁占用很长时间，并且后续还有读者不断占用读锁，这就造成了写者饥饿的问题，怎么解决？
所有读者退出占用锁，等待写者写入完毕之后，再读。
避免死锁主要有 3种方式
加锁顺序
	一个线程如果要获取多个锁，必须按照一定的顺序去获取，比如要获取A B C 三把锁，我们规定，必须获取到了 AB 两把锁，才能去获取 C锁
加锁时限
	一个线程尝试去获取锁，如果在指定的时间内获取不到，就放弃等待锁，并释放自己现在所持有的锁，然后随机等待一定时间，再去获取锁
	这里要注意的是 ，等待的时间一定要是随机，不然可能出现 两个线程都释放资源，然后等待相同时间，然后再一起去获取锁，于是又死锁，这种现象称为活锁
死锁检测
	利用数据结构，如一个map,然后每次线程的上锁，和获取不到锁，都记录在里面，当一个线程获取不到锁的时候，就去遍历查看这个map，看一下有没有死锁，有的话就将整个map里所有的锁全部释放，然后各个线程稍作等待，再去竞争锁。
	这里还可以优化下，设置优先级，释放所有锁的时候，不释放优先级高的锁，能提高性能。

线程和进程的区别
根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位
资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的
影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行
什么是协程，什么情况下可以使用协程
一个线程可以有很多个协程，协程可以理解为一个函数。
线程阻塞不会影响其他线程执行，协程阻塞，该线程的其他协程也会被阻塞。

在有大量IO操作业务的情况下，我们采用协程替换线程，可以到达很好的效果，一是降低了系统内存，二是减少了系统切换开销，因此系统的性能也会提升。
在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集型的任务中才会发挥作用。
协程只有和异步IO结合起来才能发挥出最大的威力。
通过同步的方式实现异步调用。
进程间通信的方式：
1.管道：速度慢，容量有限，只有父子进程能通讯    
2.FIFO：任何进程间都能通讯，但速度慢    
3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题    
4.信号量：不能传递复杂消息，只能用来同步    
5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存
内存泄漏和内存溢出：
内存溢出（out of memory）：是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个int,但给它存了long才能存下的数，那就是内存溢出。
内存泄露（memory leak）：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
（memory leak会最终会导致out of memory！）
c++：
什么是多态：
简单点说:“一个接口，多种实现”，就是同一种事物表现出的多种形态。
C++的多态分为静态多态与动态多态；
静态多态就是函数重载和运算符重载，因为在编译期就可以确定函数地址。，所以称为静态多态。
动态多态就是通过继承重写基类的虚函数实现的多态，因为是在运行时在虚函数表中寻找调用函数的地址，所以称为动态多态。
为什么要把基类的析构函数定义为虚函数？
在用基类操作派生类时，为了防止只执行基类的析构函数，不执行派生类的析构函数。因为这样的删除只能够析构基类对象, 而不能析构子类对象, 会造成内存泄漏。有虚函数，delete通过子类的虚表指针调用子类的析构函数，然后自动调用基类析构，就不会有内存泄露。
为什么要有虚函数表（存函数指针的数组）？
实现多态，父类对象的指针指向父类对象调用的是父类的虚函数，指向子类对象调用的是子类的虚函数。
同一个类的多个对象的虚函数表是同一个，所以这样就可以节省空间，一个类自己的虚函数和继承的虚函数还有重写父类的虚函数都会存在自己的虚函数表。
什么是虚函数
虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。
什么是纯虚函数
纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类
构造函数可以是虚函数吗
不可以，虚函数需要对象的虚表指针访问虚表调用，虚表指针必须实例化对象才会存在，没有构造函数就不能实例化，逻辑不通。
四种cast：
static_cast：没有运行时类型检查来保证转换的安全性；
1、于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证；
2、用于类层次结构中基类（父类）和 派生类 （子类）之间指针或引用的转换。　　
进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；　　
进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
3、把空指针转换成目标类型的空指针。　　
4、把任何类型的表达式转换成void类型。

dynamic_cast：dynamic_cast是运行时处理的，运行时要进行类型检查，而其他三种都是编译时完成的。
1、不能用于内置基本数据类型间的强制转换；
2、进行继承关系的类之间的转换，基类中一定要有虚函数，否则编译不通过；
3、dynamic_cast转换若成功，返回的是指向类的指针或引用；若失败则会返回NULL；
4、在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。
const_cast：主要是用于改变类型的常量属性。但是并不能改变被转换的常量的值。（传参时要求是非const可以使用）。
reinterpret_cast：纯字节转换，把一个指针或者引用，转换为任意类型，再转换会原来类型，指针或引用的值不变。（不能转换常量const，体现了const_cast的特殊性）

如何避免循环依赖（A类包含B类，B类包含A类）：
1、使用指针代替变量声明
2、既然A、B两个类相互包含说明A、B两个类的耦合度比较高，可以给A、B写一个基类，然后使用派生，将A、B声明为该类的子类，修改所需的变量即可。

什么是智能指针，有哪几种，作用，实现原理；
unique_ptr：unique_ptr 不共享它所管理的对象：它无法复制到其它unique_ptr；无法通过值传递到函数。但是资源管理权限可以通过move函数（将原本p1的内存传递给p2，避免了传递拷贝）实现转移，通过move（ptr）也可以实现传参。
auto_ptr:没有unique_ptr的限制性，两个指针可以指向同一个对象。这是不能接受的，因为程序将试图删除同一个对象两次，一次是 ps 过期时，另一次是 vocation 过期时。在c++11中被unique_ptr替换了。
shared_ptr: 是一个标准的共享所有权的智能指针，允许多个指针指向同一个对象，使用了引用计数的机制，多一个指针执行对象，引用计数就加1，只有引用计数为0时，对象才会被释放。
weak_ptr:被设计为与 shared_ptr 共同工作，像是一个旁观者，观察者意味着 weak_ptr 只对 shared_ptr 进行引用，而不改变其引用计数，当被观察的 shared_ptr 失效后，相应的 weak_ptr 也相应失效。不具有普通指针的行为，没有重载 operator* 和 operator-> ，但是可以通过weak_ptr->lock();获得一个可用的 shared_ptr 管理的对象， 从而操作资源。用处（weak_ptr 可用于打破循环引用，禁止套娃行为）。
const 关键字的使用
const修饰符可以把对象转变成常数对象，意思就是说利用const进行修饰的变量的值在程序的任意位置将不能再被修改，就如同常数一样使用。因为常量在定义后就不能被修改，所以定义时必须初始化。

修饰指针:	const int* p1 = &a; //指针指向对象是一个常量		int* const p2 = &a;//指针本身是个常量
const修饰函数参数：防止传入的参数代表的内容在函数体内被改变，但仅对指针和引用有意义。因为如果是按值传递，传给参数的仅仅是实参的副本，即使在函数体内改变了形参，实参也不会得到影响。
const修饰函数返回值：也是用const来修饰返回的指针或引用，保护指针指向的内容或引用的内容不被修改，也常用于运算符重载。归根究底就是使得函数调用表达式不能作为左值。
const成员函数：const_reference operator[]( size_type pos ) const;    作用：只要是防止成员函数修改类对象的内容，只能调用const函数。
volatile 关键字的作用
	遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问
Static
static修饰之后，变量在全局存储区分配内存；
1、被 static 修饰的变量或函数属于类变量或类方法，可以通过类名.变量名直接引用，而不需要 new 出一个类来；
2、静态数据成员可以实现多个对象之间的数据共享；
3、因为static成员函数在类实例化之前就已经存在了，所以不能访问非静态类成员和方法，可能类还没有实例化，会产生错误。
STL的六大组件
（1）容器——概念：对常见数据结构的封装。（2）分类：1.序列式容器：string，vector，list,deque，array，forward_list。2.关联式容器：以红黑树为底层实现：map,set,multimap,multiset。以哈希为底层结构实现：unordermap，unorderset，unorder_multimap，unorder_multiset。
（2）迭代器——本质：被封装的指针。    
概念：提供一种结构，可以依次遍历容器中的元素，而又无需暴露底层实现。
作用：主要是给算法来应用的，让算法可以操作任意容器中的数据。
（3）算法——分类：1.与容器相关联的算法，即属于容器中的成员函数。    
通用算法：sort，reverse，foreach。
注意：算法想要操作不同容器中的数据，必须借助迭代器。
（4）仿函数（函数对象）——概念：可以像函数一样使用的对象。
实现：将（）进行运算符重载。    
作用：用来配置算法的功能，使算法更加灵活。
（5）适配器——是一种设计模式。    
概念：将其他结构进行封装后形成一种新的结构。   
容器适配器：stack，queue，priority_queue，bind。
（6）空间配置器——高效为STL中的各个容器申请和释放空间，以及对空间进行管理。
map、mutlimap 和unoderedmap：
Map：底层实现是红黑树，所以具有自动排序功能，是有序的关联性容器，key值不能重复，使用中序遍历可将键值按照从小到大遍历出来。有点就是有序性。
map在增删查三项上均弱于unordered_map，内存使用情况：map略少；
Mutli_map:红黑树，key可重复;
Unodered_map:底层实现是哈希表，因此元素排列顺序是杂乱的，是无序关联容器；查找速度快。缺点：建立哈希表比较耗费时间。
在需要有序性或者对单次查询有时间要求的应用场景下，应使用map，其余情况应使用unordered_map。

有多少种迭代器：
输入迭代器（input_iterator）：只读，不写，单边扫描，只能递增；
输出迭代器（output_iterator）:只写，不读，单边扫描，只能递增；
前向迭代器（forward_iterator）:可读写，多遍扫描，只能递增；（map）
双向迭代器（bidirectional_iterator）：可读写，多遍扫描，可递增递减；（双向链表）
随机访问迭代器（random_access_iterator）：可读写，多编扫描，支持全部迭代器运算。（数组，string）
Stack和queue没有迭代器
回调函数：
首先明确一个概念，回调函数也是普通函数，是因为程序通过参数把该函数的函数指针传递给了其它函数，在那个函数里面调用这个函数指针就相当于调用这个函数，这样的过程就叫回调，而被调用的函数就叫回调函数。看得出来，回调的本质是函数指针传递，所以想要理解回调机制，先要理解函数指针。

网络：
一、TCP和UDP的区别：
Tcp：是需要建立连接的，面向字节流的、提供可靠性的传输服务，相对于udp的传输速度慢，对系统资源要求多（头部开销大）。
udp：是不需要建立连接的，面向报文的，不可靠传输服务，传输速度快，协议要求少。
二、为什么说TCP面向字节流，UDP面向报文？
应用程序使用Udp协议时，每一次调用send函数，send的内容就是一段报文，udp会将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制，所以是面向报文；
而使用Tcp协议的话，调用一次send函数，这段报文并不会马上被发送出去，这段数据会以字节流的方式先存入TCP/IP协议栈中，什么时候发送是tcp决定的（有可能你调几次send才会发）。所以说tcp是面向字节流。
三、UDP的缺点：
1、即使出现网络拥堵的情况下，udp也无法进行流量控制的网络拥塞的行为；
2、传输过程中即使出现丢包，udp也不负责重发；
3、即使出现包到达顺序错乱时也没有纠正功能；
（如果需要这些细节控制，一般交由采用udp的应用程序去处理）
四、TCP和UDP的应用场景：
udp主要用于那些对高速传输和实时性较高的要求的通信或广播通信，例如：电话，视频电话(即使交流过程中出现一两个字听不清，也不影响正常交流)。
Tcp用于那些对实时性要求不是很高的场景,例如：网络直播（有延迟）。
五、TCP 通过哪些方式来保证可靠性？
确认机制：当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知；数据不会无限反复的重发，达到一定重发次数之后，如果仍然没有任何确认应答返回，就会判断为网络或者是对端主机发生了异常，强制关闭连接并且会通知应用程序信号异常强行终止。
窗口机制：每发一段进行一次确认应答的处理，这样的传输有一个缺点，就是，包的往返时间越长通信性能就越低（网络的吞吐量越差）。
为了解决这个问题，引入了窗口这个概念，窗口大小就是无需等待确认应答而可以继续发送的数据的最大值；
	没有滑动窗口机制，没有收到确认应答的数据都会进行重发，而有了滑动窗口机制之后，即使有少部分的确认应答没有收到，也能通过下一个确认应答进行确认；
	收到确认应答的数据，就可以从缓存区清除；
高速重发机制：引入了窗口机制之后，重发都会依据“高速重发机制”（接收端没有收到自己所期望的序号的数据，发送端一旦收到某个确认应答之后，又连续三次收到同一个确认应答，发送端就认为数据丢失，需要进行重发，这种机制比起超时机制可以提供更为快速的重发服务）；
流控制：发送端根据接收端的实际接收能力，控制发送的数据量，就是流控制；
解决的问题（发送端根据自己的实际情况发送数据，接收端可能收到一个毫无关系的数据包，有可能在处理这个数据包时耗费一些时间，在高负荷的情况下无法接受任何数据如此一来，造成本该接收的数据丢失，又会触发重发机制，从未导致网络流量的无端浪费。）
	具体操作：接收端主机向发送端主机通知自己可以接受数据的大小（这个大小就是窗口的大小，窗口大小是由接收端主机确定的），发送端就会发送不超过这个限度的数据。
		发送端会时不时的发送一个窗口确认的数据段，此数据段仅含有一个字节，以获取最新的窗口大小信息。

拥塞控制：
	解决的问题：计算机网络处在一个共享的环境中，因此有可能因为其他主机之间的通信使得网络拥堵，在出现网络拥堵时，如果突然发送一个较大的数据，极有可能导致网络的瘫痪。
	具体操作： 慢启动：窗口数目指数增加(超时之后：窗口清零，慢启动阀值设置为当前一半； 触发快速重发之后：慢启动阀值设置为当前一半，窗口为阀值+3；这个过程也叫快回复)窗口数量到达阀值之后，就会+1增长，而不是指数增长。
延迟确认应答：
	解决的问题：接收数据的主机如果每次都立刻回复确认应答的话，可能会返回一个较小的窗口，那是因为刚接收完数据，缓冲区已满，降低了网络利用率。
	具体操作：两个数据段返回一次应答（在没有收到2*数据段是不作应答；其他情况，最大延迟0.5秒发送确认应答）；
	因为窗口机制，大可不必每一个数据段都进行一次确认应答。 
六、在浏览器输入网址之后，在界面显示之前发生了什么？
域名解析 –> 发起TCP的3次握手 –> 建立TCP连接后发起http请求 –> 服务器响应http请求，浏览器得到html代码 –> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –> 浏览器对页面进行渲染呈现给用户。

七、域名（DNS）解析流程：
1、 浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址，如果有，解析结束。
2、如果浏览器缓存中没有（专业点叫还没命中），浏览器会检查操作系统缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在windows中可通过c盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的ip地址，那浏览器会首先使用这个ip地址。
3、如果至此还没有命中域名，才会真正的请求本地域名服务器（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。
4、如果LDNS仍然没有命中，就直接跳到Root Server 域名服务器请求解析；
5、根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址；
6、此时LDNS再发送请求给上一步返回的gTLD；
7、接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器；
8、Name Server根据映射关系表找到目标ip，返回给LDNS；
9、LDNS缓存这个域名和对应的ip；
10、LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束。

八、http请求：post和get的区别（没总结好）
GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），POST把提交的数据放置在HTTP包的包体中。
POST的安全性要比GET的安全性高，这里安全的含义是真正的Security的含义。比如：通过GET提交数据，用户名和密码将明文出现在URL上，
因为：(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器返回数据.
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器返回数据.

三次握手：
三次握手主要只为了确认双方的数据收发能力，为可靠性传输做准备。
第一次握手：客户端给服务端发送一个请求连接的数据包（SYN），服务端收到这个数据包。
（这个时候就可以知道客户端的发送能和服务端的接收能力没有问题）
第二次握手：服务端给客户端回一个请求连接的包并且把序列号+1作为确认应答（SYN+ACK），然后客户端收到了；
（现在就知道服务端的发送能力和客户端的接收能力也没有问题，但是服务端不知道客户端有没有收到这个包，所以要有第三次握手）
第三次握手：客户端把服务端发的包的序列号+1作为确认应答（ACK），发送给服务端，这个时候服务端就知道客户端的接收能力没有问题，可以进行通信了。

在这个过程中，不光只是确认双方的接收能力，TCP首部中也包含序列号、确认号、通信的窗口大小信息等。为可靠性传输做好了充足的准备。

四次挥手：
四次挥手是tcp断开连接的一个过程。
第一次挥手：请求端给接收方发一个请求断开连接的包（FIN），表示我没有数据要发给你了，请求断开连接；
第二次挥手：接收方收到了FIN之后，会给请求端回两个包，一个是确认收到的包，还有一个是FIN包（第三次挥手）；（为什么不能像三次握手那样，ACK和请求一次发送呢，这是因为，接收方需要确认自己是否还有数据没有发送完，把自己该发的数据发送完，才能请求断开连接，所以只能先回一个ACK包）
第三次挥手：接收方发完FIN包之后，就进入了close状态；
第四次挥手：请求端收到了FIN包之后，也会回一个ACK包，并且进行一个2倍的最大数据存活时间（2MSL）的等待，才会进入close状态，然后断开连接。
（为什么要等待2MSL？1、要保证接收方收到了最后一个ACK包，如果没有收到，超时之后，接收方会再给请求端发送一次FIN包，然后请求端回ACK包，循环等待，直到接收方收到了；2、如果TCP/IP协议栈中有残留数据，它的最大存活时间是MSL，2MSL可以确保这些数据清空，防止，下次有新连接进来，旧数据影响正常通信）
QT相关
qt connect 用法（最后一个参数）；
Qt::AutoConnection： 默认值，使用这个值则连接类型会在信号发送时决定。如果接收者和发送者在同一个线程，则自动使用Qt::DirectConnection类型。如果接收者和发送者不在一个线程，则自动使用Qt::QueuedConnection类型。
Qt::DirectConnection：槽函数会在信号发送的时候直接被调用，槽函数运行于信号发送者所在线程。效果看上去就像是直接在信号发送位置调用了槽函数。这个在多线程环境下比较危险，可能会造成奔溃。
Qt::QueuedConnection：槽函数在控制回到接收者所在线程的事件循环时被调用，槽函数运行于信号接收者所在线程。发送信号之后，槽函数不会立刻被调用，等到接收者的当前函数执行完，进入事件循环之后，槽函数才会被调用。多线程环境下一般用这个。
Qt::BlockingQueuedConnection：槽函数的调用时机与Qt::QueuedConnection一致，不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。
Qt::UniqueConnection：这个flag可以通过按位或（|）与以上四个结合在一起使用。当这个flag设置时，当某个信号和槽已经连接时，再进行重复的连接就会失败。也就是避免了重复连接。
moc文件里有什么
moc是QT的预编译器，用来处理代码中的slot，signal，emit，Q_OBJECT等。
moc文件是对应的处理代码，也就是Q_OBJECT宏的实现部分。

设计模式
设计模式有几大原则？
很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的。
•SOLID原则-SRP单一职责原则：一个类只负责完成一个职责或者功能。高内聚，低耦合
•SOLID原则-OCP开闭原则：添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。
•SOLID原则-LSP里式替换原则：一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象之间的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有发生变化。
里式替换原则对继承进行规范上的约束：
子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
子类中可以增加自己特有的方法
当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。
首先了解继承的优缺点
优点：
子类拥有父类的所有方法和属性，提高了代码的可复用性。
提高了代码的扩展性，子类不但拥有了父类的所有功能，还可以添加自己的功能。
缺点：
继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法。
降低了代码的灵活性。因为继承时，父类会对子类有一种约束。
增强了耦合性。当需要对父类的代码进行修改时，必须考虑到对子类产生的影响。有时修改了一点点代码都有可能需要对打断程序进行重构。

•SOLID原则-ISP接口隔离原则：客户端不应该强迫依赖它不需要的接口。部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数
•SOLID原则-DIP依赖倒置原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象其核心思想是：要面向接口编程，不要面向实现编程。
依赖、倒置原则的作用：
1、依赖倒置原则可以降低类间的耦合性。
2、依赖倒置原则可以提高系统的稳定性。
3、依赖倒置原则可以减少并行开发引起的风险。
4、依赖倒置原则可以提高代码的可读性和可维护性。
依赖倒置原则的实现方法：
1、依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。
2、每个类尽量提供接口或抽象类，或者两者都具备。
3、变量的声明类型尽量是接口或者是抽象类。
4、任何类都不应该从具体类派生。
5、使用继承时尽量遵循里氏替换原则。
（**）
•KISS原则：不要使用同事可能不懂的技术来实现代码；不要重复造轮子，善于使用已经有的工具类库；不要过度优化。
•DRY原则：不要重复自己，将它应用在编程中，可以理解为：不要写重复的代码
•YAGNI原则:不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。
•LOD法则:不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。

简单工厂模式：
1、简单工厂模式的结构组成：
工厂类：工厂模式的核心类，会定义一个用于创建指定的具体实例对象的接口。
 抽象产品类：是具体产品类的继承的父类或实现的接口。
 具体产品类：工厂类所创建的对象就是此具体产品实例。
2、简单工厂模式的特点：
工厂类封装了创建具体产品对象的函数。
3、简单工厂模式的缺陷：
扩展性非常差，新增产品的时候，需要去修改工厂类。
工厂方法模式：
工厂方法模式的结构组成：
1. 抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。
2. 具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式。
3. 抽象产品类：它是具体产品继承的父类（基类）。
4. 具体产品类：具体工厂所创建的对象，就是此类。
工厂方法模式的特点：
工厂方法模式抽象出了工厂类，提供创建具体产品的接口，交由子类去实现。
工厂方法模式的应用并不只是为了封装具体产品对象的创建，而是要把具体产品对象的创建放到具体工厂类实现。
工厂方法模式的缺陷：
每新增一个产品，就需要增加一个对应的产品的具体工厂类。相比简单工厂模式而言，工厂方法模式需要更多的类定义。
一条生产线只能一个产品。
抽象工厂模式：
抽象工厂模式的结构组成（和工厂方法模式一样）：
1. 抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。
2. 具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式。
3. 抽象产品类：它是具体产品继承的父类（基类）。
4. 具体产品类：具体工厂所创建的对象，就是此类。
抽象工厂模式的特点：
提供一个接口，可以创建多个产品族中的产品对象。如创建耐克工厂，则可以创建耐克鞋子产品、衣服产品、裤子产品等。
抽象工厂模式的缺陷：
同工厂方法模式一样，新增产品时，都需要增加一个对应的产品的具体工厂类。

单例模式：
饿汉式：在类加载的时候，instance静态实例就已经创建并初始化好了
优点：线程安全；缺点：不支持延迟加载；

懒汉式：懒汉式在第一次用的时候实例化，考虑到线程安全问题，需要加锁；
优点：支持延时加载；
缺点：如果频繁地用到，那频繁加锁、释放锁及并发度低等问题；如果这个单例类偶尔会被用到，那这种实现方式还可以接受

双重检测模式：一种既支持延迟加载、又支持高并发的单例实现方式；

建造者模式：
set方法可以解决的问题：把构造函数不是必填项写到set方法里；
set解决不了的情况：
1、构造函数必填项很多；
1、假设配置项之间有一定的依赖关系，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了；
1、类是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在类中暴露set()方法。
为了解决这些问题，建造者模式就派上用场了。
我们可以把校验逻辑放置到Builder类中，先创建建造者，并且通过set()方法设置建造者的变量值，然后在使用build()方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。并且，要创建的类没有提供任何set()方法，这样我们创建出来的对象就是不可变对象了。

原型设计模式：
如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的
使用场景：如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从RPC、网络、数据库、文件系统等非常慢速的IO中读取。
这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。



好未来面试没答上来的问题总结
1、左值和右值？
2、线程共享的是进程的哪些资源？（bss，data）
3、哈希表的底层实现？（答的是map，实际是数组）
4、哈希查找值的时候，时间复杂度？哈希冲突？
4、快速排序的时间复杂度？（一开始没说对，后来说对了，不够熟练）