# 杂项

### **动态绑定：**

c++中，我们在使用基类的引用（指针）调用虚函数时，就会发生动态绑定。所谓动态绑定，就是在运行时，虚函数会根据绑定对象的实际类型，选择调用函数的版本。

多态发生的条件有三个：1. 基类中定义了虚函数 2. 派生类中对继承自基类的虚函数进行了覆盖（重写），3. 存在继承关系，在这种情况下，使用父类的指针或者引用调用虚函数时，这个调用可能在运行时，绑定到不同的子类中，产生不同的行为。



## 跳表

### **什么是跳表**

跳表全称为跳跃列表，它允许快速查询，插入和删除一个有序连续元素的数据链表。跳跃列表的平均查找和插入时间复杂度都是O(logn)。快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集（见右边的示意图）。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。



**全局变量、静态全局变量、静态局部变量和局部变量的区别**

变量可以分为：全局变量、静态全局变量、静态局部变量和局部变量。

(1) 按存储区域分，全局变量、静态全局变量和静态局部变量都存放在内存的静态存储区域，局部变量存放在内存的栈区。

(2) 按作用域分， 全局变量在整个工程文件内都有效；静态全局变量只在定义它的文件内有效；静态局部变量只在定义它的函数内有效，只是程序仅分配一次内存，函数返回后，该变量不会消失；局部变量在定义它的函数内有效，但是函数返回后失效。

   全局变量(外部变量)的说明之前再冠以static就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。

  从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。

(1) static 函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件

(2) static全局变量与普通的全局变量有什么区别：static全局变量只初始化一次，防止在其他文件单元中被引用;

(3) static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；
(4) static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝.
(5) 全局变量和静态变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知。



