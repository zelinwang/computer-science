## 一、RPC作用

RPC作为分布式系统常见的一种通信方法，通俗来讲，RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。

## 二、框架需解决问题

RPC要达到的目标：远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。

### 1、Call ID映射，解决告诉远程主机我们要调用哪个函数；

在本地调用中，我们可以通过函数指针指定函数体，调用具体函数，然后编译器就会帮我们调用相应的函数指针；但是在远程调用中，因为两个进程的地址空间不一样，所以无法通过调用函数指针调用函数。所以，在RPC中，所有函数必须有一个唯一的ID，在客户端和服务端分别维护一个 {函数 <–> Call ID} 的对应表。当客户端需要进行远程调用时，基于调用的函数查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。

### 2、序列化和反序列化，解决怎么把参数值传送给远程函数。

在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。另外，有时候客户端和服务端使用的都不是同一种语言。
这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。

### 3、网络传输，解决数据的传输。

网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。网络传输可以使用TCP协议，保证可靠传输；也可以使用UDP，加快传输速度。

### 4、服务注册中心，解决分布式架构中，一个服务势必会有多个实例，如何获取实例的问题。

可以使用Zookeeper作为注册中心，在调用时，从Zookeeper获取服务的实例列表，再从中选择一个进行调用。

### 5、redis缓存，如果每次都去注册中心查询列表，效率很低，那么就要加缓存。

### 6、异步调用AIO,客户端总不能每次调用完都等着服务端返回数据，所以就要支持异步调用。

AIO作为异步非阻塞，AIO发起IO操作之后，通知服务器去完成函数操作，这个时间客户端可以去做其他的事情。等到服务器完成操作之后，就会调用客户端的接口，返回结果数据。

### 7、使用线程池

针对高并发的客户端请求，服务端可以维护一个线程池，针对每次的客户端的请求，可以直接从线程池中拿出一个线程，直接去执行客户端的任务，省去了每次创建线程的开销，同时提高了服务端的响应速度。

## 三、RPC框架三个核心角色

1. 服务提供者（Server）对外提供后台服务，将自己的服务信息，注册到注册中心
2. 注册中心（Registry）用于服务端注册远程服务以及客户端发现服务。

3. 服务消费者（Client） 从注册中心获取远程服务的注册信息，然后进行远程过程调用。

## 四、RPC远程调用过程

1. 服务调用方（client）调用以本地调用方式调用服务；
2. client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；在Java里就是序列化的过程；
3. client stub找到服务地址，并将消息通过网络发送到服务端；
4. server stub收到消息后进行解码,在Java里就是反序列化的过程；
5. server stub根据解码结果调用本地的服务；
6. 本地服务执行处理逻辑；
7. 本地服务将结果返回给server stub；
8. server stub将返回结果打包成消息，Java里的序列化；
9. server stub将打包后的消息通过网络并发送至消费方；
10. client stub接收到消息，并进行解码, Java里的反序列化；
11. 服务调用方（client）得到最终结果。

RPC框架的目标就是要2~10这些步骤都封装起来。

## 五、RPC框架涉及技术

a.建立通信
首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。
当前很多RPC框架都直接基于netty这一IO通信框架，推荐使用Netty 作为底层通信框架。

b.网络传输
数据传输采用什么协议（二进制数据格式组织）？
数据该如何序列化和反序列化？(kryo/protobuf/protostuff/hessian/fastjson/…)

c.服务寻址
1）服务注册
服务提供者启动后主动把服务注册到服务中心，注册中心存储了该服务的IP、端口、调用方式(协议、序列化方式)等信息。

2）服务发现
服务消费者第一次调用服务时，会通过注册中心找到相应的服务提供方地址列表，并缓存到本地，以供后续使用。当消费者再次调用服务时，不会再去请求注册中心，而是直接通过负载均衡算法从IP列表中取一个服务提供者的服务器调用服务。

d.服务调用
服务消费者进行本地调用（通过代理Proxy）之后得到了返回值。实际上是在Proxy中封装了一系列的过程，包括序列化、请求服务提供者、反序列化等等。
创建Proxy的方式?(jdk proxy/javassist/cglib/asm/bytebuddy)
Proxy还能做什么？软负载均衡(加权随机、加权轮询、最小负载、一致性Hash…) 、集群容错(Fail-fast、Failover、Fail-safe、Fail-back)、同步/异步调用、流控、熔断、降级、限流、隔离和超时…(服务治理)
