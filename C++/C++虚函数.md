## 一、C++构造函数可以调用虚函数吗？

在构造函数中是调用虚函数依然“生效”的，但是调用结果可能不是预期那样。

构造函数调用层次会导致一个有趣的两难选择。试想：如果我们在构造函数中并且调用了虚函数，那么会发生什么现象呢？在普通的成员函数中，我们可以想象所发生的情况——虚函数的调用是在运行时决定的。这是因为编译时这个对象并不能知道它是属于这个成员函数所在的那个类，还是属于由它派生出来的某个类。于是，我们也许会认为在构造函数中也会发生同样的事情。

**然而，情况并非如此。对于在构造函数中调用一个虚函数的情况，被调用的只是这个函数的本地版本。也就是说，虚机制在构造函数中不工作。**

## 二、构造函数中为什么不允许被调用虚函数？

### 1、概念上

在概念上，构造函数的工作是生成一个对象。在任何构造函数中，可能只是部分形成对象——我们只能知道基类已被初始化，但并不能知道哪个类是从这个基类继承来的。然而，虚函数在继承层次上是“向前”和“向外”进行调用。它可以调用在派生类中的函数。如果我们在构造函数中也这样做，那么我们所调用的函数可能操作还没有被初始化的成员，这将导致灾难发生。

### 2、机械上

当一个构造函数被调用时，它做的首要的事情之一就是初始化它的vptr。然而，它只能知道它属于“当前”类——即构造函数所在的类。于是它完全不知道这个对象是否是基于其它类。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码——既不是为基类，也不是为它的派生类（因为类不知道谁继承它）。所以它使用的vptr必须是对于这个类的vtable。而且，只要它是最后的构造函数调用，那么在这个对象的生命期内，vptr将保持被初始化为指向这个vtable。但如果接着还有一个更晚派生类的构造函数被调用，那么这个构造函数又将设置vptr指向它的vtable，以此类推，直到最后的构造函数结束。vptr的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是按照从基类到最晚派生类的顺序的另一个理由。

但是，当这一系列构造函数调用正发生时，每个构造函数都已经设置vptr指向它自己的vtable。如果函数调用使用虚机制，它将只产生通过它自己的vtable的调用，而不是最后派生的vtable（所有构造函数被调用后才会有最后派生的vtable）。另外，许多编译器认识到，如果在构造函数中进行虚函数调用，应该使用早绑定，因为它们知道晚绑定将只对本地函数产生调用。无论哪种情况，在构造函数中调用虚函数都不能得到预期的结果。


## 三、总结

1. 构造函数跟虚构函数里面都可以调用虚函数，编译器不会报错。
2. C++ primer中说到最好别用。
3. 由于类的构造次序是由基类到派生类，所以在构造函数中调用虚函数，虚函数是不会呈现出多态的。
4. 类的析构是从派生类到基类，当调用继承层次中某一层次的类的析构函数时意味着其派生类部分已经析构掉，所以也不会呈现多态。
5. 因此如果在基类中声明的纯虚函数并且在基类的析构函数中调用之，编译器会发生错误。