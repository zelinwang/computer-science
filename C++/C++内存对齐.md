# 内存对齐

内存对齐，**memory alignment**。为了提高程序的性能，数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；然而，对齐的内存访问仅需要一次访问。内存对齐一般讲就是CPU access memory的效率(提高运行速度)和准确性(在一些条件下，如果没有对齐会导致数据不同步现象)。依赖CPU，平台和编译器的不同。一些CPU要求较高(这句话说的不准确，但是确实依赖CPU的不同)，而有些平台已经优化内存对齐问题，不同编译器的对齐模数不同。总的来说内存对齐属于编译器的问题。

一般情况下不需要理会内存对齐问题，内存对齐是编译器的事情。但碰到一些问题上还是需要理解这个概念。毕竟c/c++值直接操作内存的语言。需要理解程序在内存中的分布和运行原理。

在32位编译环境下默认4字节对齐，在64位编译环境下默认8字节对齐。

## 一、内存对齐的原因

### 1、平台原因(移植原因)

不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

### 2、性能原因

数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问（这里的两次访问是指CPU将数据读取到CPU缓存中，如果没有对齐，可能需要再一次从内存中读取数据到CPU缓存，造成效率降低）；而对齐的内存访问仅需要一次访问。

## 二、内存对齐的规则和范例

成员的内存分配规律：从结构体的首地址开始向后依次为每个成员寻找第一个满足条件的首地址x，该条件是x % N = 0，并且整个结构的长度必须为各个成员所使用的对齐参数中最大的那个值的最小整数倍，不够就补空字节。结构体中所有成员的对齐参数N的最大值称为结构体的对齐参数。

编译器提供手动指定对齐值的关键字 #pragma pack(N)，可以手动设置对齐的字节数，比如#pragma pack(1），#pragma pack(4)等。这里即为N。若没有手动指定，那么编译器就会默认将成员变量中最大的类型字节数设置为对齐值：m

### 1） 整体对齐值

首先计算对齐单位 n = min(N，m)，然后整体对齐后的字节数应该为n的倍数，不够的在最后面填补占位。

### 2） 成员对齐值

首个成员的偏置地址(offset) = 0。

假定该成员的类型占字节数 j，那么本成员的偏移地址(offset)：min(n, j)的整数倍。

### 结构体变量内存对齐三原则

1、变量的起始地址能够被其对齐值整除，结构体变量的对齐值为最宽的成员大小。
2、结构体每个成员相对于起始地址的偏移能够被其自身对齐值整除，如果不能则在前一个成员后面补充字节。
3、结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节。

# 字节大小

![](E:\Code\复习心得\res\picture\字节大小.png)

示例代码

```c++
class A
{
public:
    A() {}
};

class VA
{
public:
    VA() {}
    virtual void fun() {}
};

class B
{
public:
    B() {}
private:
    double d;//8字节
    int a;
    char c;
};

class VB
{
public:
    VB() {}
    virtual void fun() { }
private:
    double d;//8字节
    int a;
    char c;
};

class C
{
public:
    C() { }

private:
    int a;
    double d;
    char c;
};
```

在64位系统上，A的大小是1字节，B的大小是16字节，VB的大小是24字节，C的大小是24字节，VA的大小是8字节 。因为字节对齐的原则，B的大小是16字节，VB因为有虚函数，要加一个指向虚函数表的指针所以VB的大小是16+8一共是24字节。C大小是根据对齐原则，所以是24字节

为何64位下一个指针大小为8个字节？
通过上面的介绍，我们对指针有了个清楚的认识。那么，随之就引入了本篇文章的重点了，为何64位下一个指针大小为8个字节。其实，这个原因也是很简单的，只是可能很多小伙伴从没去想过这个问题，所以当问到这个问题的时候，可能就是一脸懵逼，当然，我第一次被问到这个问题的时候也是一脸懵逼，哈哈哈。

现在先引入一个计算机常识，那就是，无论是什么类型的指针变量，在32位系统下，一个指针变量所占用的空间是4个字节，在64位下，一个指针变量所占用的空间是8个字节。

那么为何会是这个值呢？就听我给你细细讲来。

首先，我们得知道另一个计算机常识，那就是，一个字节(byte)占用多少位(bit)，没错，是8位。这里，你可能会发现一个有趣的地方，32 bit == 4 byte ， 64 == 8 byte。这不是巧合，哈哈哈。

现在我问你一个问题，64位能表示的数值个数是多少？很简单，2^64个，数值范围就是从0到2^64 - 1，这也是如今64位CPU的寻址范围，用16进制表示就是：0---FFFF FFFF FFFF FFFF(F是数值15，二进制就是1111,刚好是四位，所以2个16进制位就是一个字节)，那么重点就从这儿开始了，如果想让一个指针变量存储的数值能表示完所有的寻址范围(也就是所有的地址值)，那么毋庸置疑，他的存储空间必须是大于等于64bit，也就是8个字节，少一个bit，都不能完整的表示完所有的寻址范围，刚好，8个字节刚好能不多一位不少一位的表示完所有的寻址范围，因此就是8个字节。同理的32位下就是4个字节
