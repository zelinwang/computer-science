# 初始化列表和构造函数

## 一、初始化列表

与其他函数不同，构造函数除了有名字，参数列表和函数体之外，还可以有初始化列表，初始化列表以冒号开头，后跟一系列以逗号分隔的初始化字段。在C++中，struct和class的唯一区别是默认的访问性不同，而这里我们不考虑访问性的问题。

## 二、构造函数的两个执行阶段

构造函数的执行可以分成两个阶段，**初始化阶段**和**计算阶段**，初始化阶段先于计算阶段。

所有类类型（class type）的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。

## 二、区别

### 成员是按照他们在类中出现的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化。

初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。使用初始化列表主要是基于性能问题，对于内置类型，如int, float等，使用初始化类表和在构造函数体内初始化差别不是很大，但是对于类类型来说，最好使用初始化列表，**使用初始化列表少了一次调用默认构造函数的过程**，这对于数据密集型的类来说，是非常高效的。

除了性能问题之外，有些时场合初始化列表是不可或缺的，以下几种情况时**必须**使用初始化列表

- **常量成员**，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
- **引用类型**，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
- **没有默认构造函数的类类型**，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。

## 三、初始化列表作用

### 缩窄

初始化列表禁止将数值赋值给它无法储存的变量，这个就叫缩窄

```
char a = 6.15;   //可以编译通过
char b {1.666};  //错误的，编译错误
char c = {66};   //可以
double d = {66}; //可以将小的数据存到大的数据里面
```

## 四、类成员变量的初始化顺序

1. 成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。这点在《EffectiveC++》中有详细介绍。
2. 如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。
3. 注意：类成员在定义时，是不能初始化的
4. 注意：类中const成员常量必须在构造函数初始化列表中初始化。
5. 注意：类中static成员变量，必须在类外初始化。
6. 静态变量进行初始化顺序是基类的静态变量先初始化，然后是它的派生类。直到所有的静态变量都被初始化。这里需要注意全局变量和静态变量的初始化是不分次序的。这也不难理解，其实静态变量和全局变量都被放在公共内存区。可以把静态变量理解为带有“作用域”的全局变量。在一切初始化工作结束后，main函数会被调用，如果某个类的构造函数被执行，那么首先基类的成员变量会被初始化。 