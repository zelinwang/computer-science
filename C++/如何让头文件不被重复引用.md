# 一、#pragma once 

使用 #pragma one 指令，将其附加到指定文件的最开头位置，则该文件就只会被 #include 一次。#pragma once 不涉及宏定义，当编译器遇到它时就会立刻知道当前文件只引入一次，所以效率很高。但值得一提的是，并不是每个版本的编译器都能识别 #pragma once 指令，一些较老版本的编译器就不支持该指令（执行时会发出警告，但编译会继续进行），即 #pragma once 指令的兼容性不是很好。目前，几乎所有常见的编译器都支持 #pragma once 指令，甚至于 Visual Studio 2017 新建头文件时就会自带该指令。可以这么说，在 C/C++ 中，#pragma once 是一个非标准但却逐渐被很多编译器支持的指令。除此之外，#pragma once 只能作用于某个具体的文件，而无法向 #ifndef 那样仅作用于指定的一段代码。

# 二、条件编译

```
#ifndef __HEADERNAME_H__
#define __HEADERNAME_H__

...//(头文件内容)

#endif
```

​		当程序中第一次 #include 该文件时，由于 __HEADERNAMENAME_H__ 尚未定义，所以会定义 __HEADERNAMENAME_H__ 并执行“头文件内容”部分的代码；当发生多次 #include 时，因为前面已经定义了 __HEADERNAMENAME_H__ ，所以不会再重复执行“头文件内容”部分的代码。#ifndef 是通过定义独一无二的宏来避免重复引入的，这意味着每次引入头文件都要进行识别，所以效率不高。但考虑到 C 和 C++ 都支持宏定义，所以项目中使用 #ifndef 规避可能出现的“头文件重复引入”问题，不会影响项目的可移植性。

​		多重包含的危险就被消除了。当头文件第一次被包含时，它被正常处理，符号__HEADERNAME_H__被定义为1。如果头文件被再次包含，通过条件编译，它的内容被忽略。符号__HEADERNAME_H__按照被包含头文件的文件名进行取名，以避免由于其他头文件使用相同的符号而引起的冲突。但是，你必须记住预处理器仍将整个头文件读入，即使这个头文件所有内容将被忽略。由于这种处理将托慢编译速度，所以如果可能，应该避免出现多重包含。

# 三、前置声明

​		我们使用前置声明的一个好处是，从上面看到，当我们在类A使用类B的前置声明时，我们修改类B时，只需要重新编译类B，而不需要重新编译a.h的（当然，在真正使用类B时，必须包含b.h）。

​		为什么我们前置声明时，只能使用类型的指针和引用呢？

​		使用前置声明只允许的声明是指针或引用的一个原因是只要这个声明没有执行,需要了解类A的大小或者成员的操作就可以了，所以声明成指针或引用是没有执行需要了解类A的大小或者成员的操作的

​		 前置声明解决两个类的互相依赖
