# C++封装继承多态

## 一、封装

隐藏对象的属性和实现细节，仅对外公开接口和对象进行交互，将数据和操作数据的方法进行有机结合。

### 1）访问限定符

1、public（共有）
2、protected（保护）
3、private（私有）

说明：
（1）public成员可以在类外直接访问。
（2）protected和private成员在类外（在此将这两种限定符都可以看成是私有的，在继承出区别）不能够访问。
（3）它们的作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止。
（4）class的默认访问权限是private，而struct为public型(因为struct要兼容C)。C++常用的是class
（5）类外：即脱离了类的作用域或者说访问时不在类的成员函数中。

**注意：访问限定符本质上是给编译器使用的，数据放在内存中是没有任何限制的**

### 二）类的作用域

- 局部作用域
- 全局作用域
- 类作用域
- 名字空间作用域

（1） 在类体外定义成员，需要使用 :: 作用域解析符指明成员属于哪个类域。
（2） 在类的作用域外，只能够通过对象或指针借助成员访问操作符.和->来访问类成员，跟在访问操作符后面的名字必须在相关联类的作用域中。
（3）成员变量在类中具有全局作用域。

## 二、继承

继承就是新类从已有类那里得到已有的特性。 类的派生指的是从已有类产生新类的过程。原有的类成为基类或父类，产生的新类称为派生类或子类。

类的继承

**单一继承：**继承一个父类，这种继承称为单一继承，一般情况尽量使用单一继承，使用多重继承容易造成混乱易出问题

**多重继承：**继承多个父类，类与类之间要用逗号隔开，类名之前要有继承权限，假使两个或两个基类都有某变量或函数，在子类中调用时需要加类名限定符如c.a::i = 1；

**菱形继承：**多重继承掺杂隔代继承1-n-1模式，此时需要用到虚继承，例如 B，C虚拟继承于A，D再多重继承B，C，否则会出错

**继承权限：**继承方式规定了如何访问继承的基类的成员。继承方式指定了派生类成员以及类外对象对于从基类继承来的成员的访问权限

**继承权限：**子类继承基类除构造和析构函数以外的所有成员

## 三、多态

可以简单概括为“一个接口，多种方法”，即用的是同一个接口，但是效果各不相同，多态有两种形式的多态，一种是静态多态，一种是动态多态

**动态多态：**   是指在程序运行时才能确定函数和实现的链接，此时才能确定调用哪个函数，父类指针或者引用能够指向子类对象，调用子类的函数，所以在编译时是无法确定调用哪个函数

使用时在父类中写一个虚函数，在子类中分别重写，用这个父类指针调用这个虚函数，它实际上会调用各自子类重写的虚函数。

运行期多态的设计思想要归结到类继承体系的设计上去。对于有相关功能的对象集合，我们总希望能够抽象出它们共有的功能集合，在基类中将这些功能声明为虚接口（虚函数），

然后由子类继承基类去重写这些虚接口，以实现子类特有的具体功能。

运行期多态的实现依赖于虚函数机制。当某个类声明了虚函数时，编译器将为该类对象安插一个虚函数表指针，并为该类设置一张唯一的虚函数表，虚函数表中存放的是该类虚函数地址。

运行期间通过虚函数表指针与虚函数表去确定该类虚函数的真正实现。

## 四、菱形继承

```c++
class A
{
public:
    int _a;
};

class B : public A
{
public:
    int _b;
};

class C : public A
{
public:
    int _c;
};

class D : public B, public C
{
public:
    int _d;
};
```

会有以下确定：

1. 容易引发二义性
2. 类B和C都共有继承A，但是D类公有继承A类的两个数据，造成了数据冗余

C++针对这种缺陷提出了另外一种继承方式叫做虚继承。

#### **虚继承**

C++使用虚拟继承（Virtual Inheritance），解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。

**虚基类构造次数**

C++编译系统只执行最后的派生类对基类的构造函数调用，而忽略其他派生类对虚基类的构造函数调用。从而避免对基类数据成员重复初始化。因此，虚基类只会构造一次。