# #define的作用

## 一、#define的变体,即#ifndef，可以防止头头文件的重复引用

**#ifndef**和**#defin**e组合,一般用于头文件中，用以实现防止多个文件对此同一个头文件的重复引用。实际使用中，即使你的头文件暂时没有被多个文件所引用，为了增加程序可读性，移植性，健壮性等,还是最好都加上。其用法一般为：

```c++
#ifndef HEAD_H
#define HEAD_H
………
#endif //HEAD_H
```

这样做之后,以后某个文件引用此头文件,就包含了#define HEAD_H，而其他文件如果再引用此头文件的话，编译器那么就会判断出来，已经define了HEAD_H，已经有其他文件引用了此文件，就可以发现重复引用头文件的问题了。

## 二、#define的变体，即#ifdef，可以实现加入自己需要的模块(源文件)

在源文件中加入

```c++
#ifdef HEAD_H
#include "head.h"
#endif
```

可以实现在源文件中加入head.h的代码，将其实现的功能加进来，即加入了head头文件

## 三、#define进行宏定义常量

可以对一些常见的变量，字符串等，进行宏定义，系统在编译期间，就会自动替换

**[注意事项]**

1. 宏定义中的变量，约定俗成用大写,以此与小写的普通变量区分开来。当然如果你故意小写，也是合法的，不过如果你想让你写的程序具有高可读性，那最好遵守此约定。

2. #define的行尾,没有分号”;”，有些人不注意,会画蛇添足地加上.有些公司招聘时候的笔试,也会考察这个细节。
3. 如果后面的宏定义中的变量和前面的有内在联系,那么后面的宏定义变量最好用前面的表示。

**[缺点]**

1. **无法对宏定义中的变量进行类型检查**

   - define定义的变量，是Compile-Time时期的变量，系统在编译时候，就将其全部替换，而不会对其变量进行类型等属性检查，相对不是很安全，可能存在潜在的问题，而没有发现。

   - 正因为其仅仅是编译时期替换，所以其定义的变量；是不会在运行时候分配内存的，不占用内存空间。

   - const定义的变量，是 Run-Time时期的变量，如果类型不匹配，系统在运行时候，就会发现并提示或报错，对应的，const变量在运行时期，也是一种变量，系统会为其分配内存。

   

2. **边界效应**

​       由于宏定义的时候，其各个分量未加括号，而在使用宏定义的时候，传递的参数是变量的表达式，然后经过系统展开后，由于优先级的原因，导致其结果不是你所希望的。

```c++
#define MUL(A,B) A*B
```

而在使用的时候，这样的调用:

```c++
int a=1, b=2, c=3, d=0;
d = MUL(a+b,c)
//经过编译时候展开,就变成了
d= a + b * c
//而不是我们所希望的
d= (a + b) * c
```

**[解决办法]**

其解决办法也很简单，就是给每个分量，都加上括号，就可以避免此类问题

```c++
#define MUL(A,B) ((A)*(B))
```

**在define数据类型的时候, 未加括号带来的问题**

在用define进行新的数据类型定义的时候，由于未加括号，会出现你所未预料到的结果。

此点其实就是上面说的边界效应，之所以将此点单独说一下，是由于此点不是普通计算结果的问题。而是数据类型的问题，问题相对更严重。

**[例子]**

#define dPS struct s *   //注意末尾无分号

当使用的时候,遇到:

dPS p1,p2;

的时候,经过编译时候替换扩展,就变成了

struct s* p1,p2;

而p2就不是我们所希望的s的指针类型了,而是一个普通的s数据结构类型的了.产生了边界效应.

**[解决办法]**

对应的解决办法也很简单,就是,遇到此类新数据类型定义的时候,还是用typedef

将上述宏定义改为:

typedef struct s * tPS; // 注意末尾有分号

而后的使用:

tPS p1,p2;

就正常了.





特殊情况时候,加了括号也无法避免错误

在宏定义中出现++或—之类的操作符的时候,即使加括号,也无法避免其中的问题

[例子]

#define MIN(A,B) ((A)<(B)?(A):(B))

如果进行如此调用

int a=1,b=3,min=0;

min=MIN(a++,b);

经过编译替换展开后,就成了

max=((a++)< (b)?(a++):(b))

计算出来的结果,就是

min=3,而不是我们所要的min=1了.

## 四、提高程序的运行效率

1、使用带参数的宏既代替了函数的功能，又避免了函数入栈和出栈操作，减少了系统的开销，提高了运行的效率。

2、宏与const修饰变量的对比，define 不分配内存，只进行文本替换，也就是代码段会变多。但是const修饰的静态存储区中分配空间，所有使用的时候只有一次拷贝。

3、宏与inline函数相比。内联函数在编译阶段会在调用内联函数的地方自动展开，没有函数压栈的开销，提升程序运行效率。