## 一、Static

### 1、static关键字主要起隐藏作用

static关键字在C\C++中都可以修饰内置类型变量、函数

static修饰内置类型变量为静态变量：
static修饰的内置类型变量分为静态全局变量和静态局部变量，静态变量内存分配在 .data段，生成的符号为local类型的符号，
在链接阶段进行符号解析时不做处理。静态变量只初始化一次，未初始化的静态变量会默认初始化为0。
静态全局变量只在本文件可见，外部文件无法访问。而静态局部变量只在定义的作用域内可见，但他们的生存周期都是整个程序运行时期。

### 2、static修饰函数

static修饰的函数为静态函数，静态函数主要是起到函数的隐藏作用，static修饰的函数只允许在当前文件中使用，在其他文件中无法找到该函数的地址，比如在一个工程中创建两个.cpp（.c）文件，main1、main2，在main1中定义一个static int add()函数并对该函数进行实现，而在main2中使用add函数是就编译会报错误，这就是由于static修饰该函数只允许在main1文件中使用造成的。在C++中有类的存在static可以修饰数据成员和成员方法

### 3、static修饰数据成员

static修饰的数据成员属于类的组成部分，static修饰的数据成员不在栈上分配内存而在.data段分配内存，static修饰的数据成员不能通过调用构造函数来进行初始化，因此static修饰的数据成员必须在类外进行初始化且只会初始化一次。

### 4、static修饰成员方法

static修饰的成员方法为静态成员方法，静态成员方法可以在类内或类外定义，但必须在类内声明；
static成员方法没有this指针，所以不能直接引用非static数据成员或调用类的非static成员方法，
只能调用类的static成员数据和static成员方法；static成员不是任何对象的组成，
不依赖对象的调用所以static成员方法不能被声明为const，因为const只限定该类的对象；static成员方法不能同时被声明为虚函数。

由于static修饰的成员方法没有this指针所以无法使用data1和调用Show函数，而对于static修饰的数据成员和成员方法由于他们是类的一部分，所以可以调用。
在类外调用static成员方法和使用类的数据成员时只需要加上类的作用域即可。他们都不依赖对象的调用

### 5、实现

代码在编译的时候，会把static修饰的变量存放到静态数据区或者全局数据区，已经初始化的数据放在.data段，没有初始化的数据存放在.bss段。

## 二、const

常变量： **const 类型说明符 变量名**

常引用： **const 类型说明符 &引用名**

常对象： **类名 const 对象名**

常成员函数： **类名::fun(形参) const**

常数组： **类型说明符 const 数组名[大小]**  

常指针： **const 类型说明符\* 指针名 ，类型说明符\* const 指针名**

首先提示的是：在常变量（**const 类型说明符 变量名）、**常引用（**const 类型说明符 &引用名**）、常对象（**类名 const 对象名）、** 常数组（**类型说明符 const 数组名[大小]），** **const”** **与 “类型说明符”或“类名”（其实类名是一种自定义的类型说明符）** 的位置可以互换。如：

 const int a=5; 与 int const a=5; 等同

类名 const 对象名 与 const 类名 对象名 等同

const是一个C++语言的限定符，它限定一个变量不允许被改变。使用const在一定程度上可以提高程序的安全性和可靠性。另外，在观看别人代码的时候，清晰理解const所起的作用，对理解对方的程序也有一些帮助。

**define与const的区别**

- define作用在预处理时，是简单地字符替换

- const作用在编译时，具有类型检查的功能
- const必须进行初始化
- 宏定义太多会导致代码膨胀

**用法1：常量**
取代了C中的宏定义，声明时必须进行初始化(!c++类中则不然）。const限制了常量的使用方式，并没有描述常量应该如何分配。如果编译器知道了某const的所有使用，它甚至可以不为该const分配空间。最简单的常见情况就是常量的值在编译时已知，而且不需要分配存储。―《C++ Program Language》
用const声明的变量虽然增加了分配空间，但是可以保证类型安全。
C标准中，const定义的常量是全局的，C++中视声明位置而定。

**用法2：指针和常量**
使用指针时涉及到两个对象：该指针本身和被它所指的对象。将一个指针的声明用const“预先固定”将使那个对象而不是使这个指针成为常量。要将指针本身而不是被指对象声明为常量，必须使用声明运算符*const。
所以出现在 * 之前的const是作为基础类型的一部分：

```c++
char *const cp;  //到char的const指针
char const *pc1; //到const char的指针
const char *pc2; //const char的指针（后两个声明是等同的）
```

从右向左读的记忆方式：
cp is a const pointer to char. 故pc不能指向别的字符串，但可以修改其指向的字符串的内容
pc2 is a pointer to const char. 故*pc2的内容不可以改变，但pc2可以指向别的字符串

且注意：允许把非 const 对象的地址赋给指向 const 对象的指针,不允许把一个 const 对象的地址赋给一个普通的、非 const 对象的指针。

**用法3：const修饰函数传入参数**
将函数传入参数声明为const，以指明使用这种参数仅仅是为了效率的原因，而不是想让调用函数能够修改对象的值。同理，将指针参数声明为const，函数将不修改由这个参数所指的对象。
通常修饰指针参数和引用参数：
void Fun( const A *in); //修饰指针型传入参数
void Fun(const A &in); //修饰引用型传入参数

**用法4：修饰函数返回值**
 可以阻止用户修改返回值。返回值也要相应的付给一个常量或常指针。

**用法5：const修饰成员函数**(c++特性)
const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数；
const对象的成员是不能修改的，而通过指针维护的对象可以修改的；
const成员函数不可以修改对象的数据，不管对象是否具有const性质。编译时以是否修改成员数据为依据进行检查。

### 实现原理

1、作用在函数中

```c++
    const int cv = 100;
    int *ptr = (int*)&cv;
    *ptr = 200;
```

经过验证，ptr可以修改值，并且在编译及运行时都没有错误；

原理：编译器编译程序之后,程序中所有a出现的地方,全部自动替换成1。

```c++
const char *a="abc"
```

编译后abc的位置在常量段，执行过程中修改会报错。

2、作用在全局中

const全局变量存储在只读数据段，编译期最初将其保存在符号表中，第一次使用时为其分配内存，在程序结束时释放，例如：val_c；const局部变量存储在栈中，代码块结束时释放，例如：val_j。****

## 三、final

C++11的关键字final有两个用途。第一，它阻止了从类继承；第二，阻止一个虚函数的重写。

> 阻止从类继承：C++11中允许将类标记为final，方法是直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误。
> 阻止虚函数重写：C++11中允许将方法标记为fianal，这意味着无法再子类中重写该方法。这时final关键字至于方法参数列表后面。

## 四、explicit

C++中的explicit关键字只能用于修饰只有一个参数的类构造函数,它的作用是表明该构造函数是显示的, 而非隐式的，跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式)。explicit关键字的作用就是防止类构造函数的隐式自动转换。explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了。 但是也有一个例外, 就是当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效，此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数。

## 五、override

C++ override从字面意思上，是覆盖的意思，实际上在C++中它是覆盖了一个方法并且对其重写，从而达到不同的作用。
在我们C++编程过程中，最熟悉的就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。
还有一个典型应用就是在继承中也可能会在子类覆盖父类的方法。

## 六、volatile

易变的，不可优化的，顺序性C/C++ Volatile变量间的操作，是不会被编译器交换顺序的

有了上面的知识就不难理解Memory修改描述符了，Memory描述符告知GCC：

1. 不要将该段内嵌汇编指令与前面的指令重新排序；也就是在执行内嵌汇编代码之前，它前面的指令都执行完毕。
2. 不要将变量缓存到寄存器，因为这段代码可能会用到内存变量，而这些内存变量会以不可预知的方式发生改变，因此GCC插入必要的代码先将缓存到寄存器的变量值写回内存，如果后面又访问这些变量，需要重新访问内存。

如果汇编指令修改了内存，但是GCC 本身却察觉不到，因为在输出部分没有描述，此时就需要在修改描述部分增加“memory”，告诉GCC 内存已经被修改，GCC 得知这个信息后，就会在这段指令之前，插入必要的指令将前面因为优化Cache 到寄存器中的变量值先写回内存，如果以后又要使用这些变量再重新读取。
使用“volatile”也可以达到这个目的，但是我们在每个变量前增加该关键字，不如使用“memory”方便。

### 1、保证内存可见性

#### 概念

可见性是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。

#### 实现原理

当对非volatile变量进行读写的时候，每个线程先从主内存拷贝变量到CPU缓存中，如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。

volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，保证了每次读写变量都从主内存中读，跳过CPU cache这一步。当一个线程修改了这个变量的值，新值对于其他线程是立即得知的。

### 2、禁止指令重排