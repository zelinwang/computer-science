## 一、模板编译

当编译器遇到一个模板时，并不会生成代码，只有实例化出模板的一个特定版本时才会生成代码。也就是只有使用（调用）模板时，编译器才生成代码。

在调用一个函数时，编译器必须掌握函数的声明。当使用一个类时，必须有类的定义，但函数成员的定义不必出现。因此在开发过程中，函数声明及类定义放在头文件，函数定义及类成员函数定义放在源文件中。

而模板则不同，为了实例化模板，编译器需要掌握函数模板及类模板成员函数的定义。所以模板的定义需要全部放在头文件中。

## 二、编译错误

因为只有实例化模板的特定版本时，编译器才会生成代码。通常模板的编译错误在三个阶段生产。

第一个阶段：编译模板本身。在这个阶段编译器检查语法错误。

第二个阶段：编译器遇到模板，如在模板函数或者类模板成员函数中调用模板函数。编译器也就是可以检查参数类型是否匹配，参数个目是否准确。

第三个阶段：模板实例化。在这阶段才可以发现类型相关错误，如对类型进行大小比较，如果类型没有重载大小写比较符，那实例化的时候就会报错。

## 三、typename和class

```c++
template <typename T>
void f(T t){ }
```

```c++
template <class T>
void f(T t){ }
```

在这里，class和typename的作用时相同的。

```c++
template <class T>
void f(T t)
{
	typedef typename T::C CC;
	CC c;
}
```

在这里typename的作用是告诉编译器后面的参数时类型，不是成员函数或者变量。

class和typename的区别就是类型说明，除此之外在泛型编程中没有区别，至于为什么不去掉class，《c++Primer》这本书中说是因为有人用习惯了，我就觉得这个说法很扯。。。

这个问题在2021年小米的面试中问到过，我答上来了。