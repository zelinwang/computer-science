## 一、孤儿进程和僵尸进程的区别

1、 一般情况下，子进程是由父进程创建，而子进程和父进程的退出是无顺序的，两者 之间都不知道谁先退出。正常情况下父进程先结束会调用wait或者 waitpid 函数 等待子进程完成再退出，而一旦父进程不等待直接退出，则剩下的子进程会被 init(pid=1)进程接收，成会**孤儿进程**。(进程树中除了 init 都会有父进程)。

2、如果子进程先退出了，父进程还未结束并且没有调用 wait或者 waitpid 函数获取 子进程的状态信息，则子进程残留的状态信息( task_struct结构和少量资源信息) 会变成**僵尸进程**。原理是将子进程成为孤儿进程，从而其父进程变为 init 进程，通过 init 进程可以处理僵尸进程。

3、**守护进程**( daemon) 是指在后台运行，没有控制终端与之相连的进程。它独立于控制终端，通常周期性地执行某种任务。守护进程脱离于终端是为了避免进程在执行过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的终端信息所打断。

## 二、进程创建

### fork创建进程

1. 进程的分裂生长模式。如果操作系统需要一个新进程来运行一个程序，那么操作系统会用一个现有的进程来复制生成一个新的进程。
2. fork函数调用一次会返回两次，返回值等于0的就是子进程，而返回值大于0的就是父进程。
3. 典型的使用fork的方法：使用fork后然后用if判断返回值，并且返回值大于0时就是父进程，等于0时就是子进程。
4. fork的返回值在子进程中等于0，在父进程中等于本次fork创建的子进程的进程ID。

## 三、fork调用流程

1. 为新进程创建task_struct,将原先进程的task_struct的内容复制给新进程
2. 给新进程分配页表，并复制原先进程的页表到新进程
3. 共享原先进程的文件
4. 设置新进程的GDT项
5. 将新进程设置成就绪态，参与进程间的轮转





Linux的一切皆文件是指，Linux世界中的所有、任意、一切东西都可以通过文件的方式访问、管理。

反过来说，是Linux和GNU世界定的规范，任何东西都挂在文件系统之上，即使它们不是文件，也以文件的形式来呈现。

有一个很关键的点，这个一切是单向的，也即所有的东西都单向通过文件系统呈现，反向不一定可行。比如通过新建文件的方式来创建磁盘设备是行不通的。

比如我们经常会讲的进程(/proc)、设备(/dev)、Socket等等，实际上都不是文件，但是你可以以文件系统的规范来访问它，修改属主和属性。



