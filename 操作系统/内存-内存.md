高端内存，地段内存，内核内存，用户内存

https://blog.csdn.net/forDreamYue/article/details/78887035



https://blog.csdn.net/forDreamYue/article/details/78887035

## 物理地址和虚拟地址

Linux采用页表机制管理内存，32位系统中页大小一般为4KB，物理内存被划分为连续的页，每一个页都有一个唯一的页号。

为了程序的的可移植性，进程往往需要运行在flat memory中；另外为了方便内核统一管理所有进程的内存布局。诸如此类的原因，Linux进程运行在虚拟地址空间（几乎所有现代操作系统都是这么设计的），虚拟地址空间也是以页为单位进行管理。

Linux进程的虚拟地址空间在实际使用的过程中需要映射到物理内存地址空间中，这是通过MMU和TLB硬件单元实现的。

虚拟地址到物理地址的映射不是一一对应的，而是乱序的，在虚拟地址空间中连续的内存页，在物理地址空间可以是不连续的。

## MMU和TLB

Linux进程发起的内存访问请求时，都是虚拟地址。虚拟地址会被CPU直接送往MMU，MMU首先在TLBs中查找是否有对应进程（ASID）的匹配的页表项，如果存在则直接引用；否则在内存中加载对应进程的页表，从中找到匹配的页表项。页表项中记录了实际物理页的基地址，再结合虚拟地址的偏移地址（偏移地址直接引用）字段，计算出具体的物理地址。

Linux进程所有的内存访问请求，都必须先通过上述机制计算出物理地址，随后才能完成物理内存的读写。

MMU包含两个物理单元：

1. table walk unit 负责从内存读取页表

2. TLBs (Translation Lookside Buffers) 负责缓存最近使用过的页表项


这里面有一个问题是，每一个进程的虚拟内存地址空间布局基本一致，必然就存在不同进程的虚拟地址一致的情况，那么MMU怎么区分接收到的虚拟地址是属于哪一个进程的呢？答案是**ASID**(Application Specific ID，也有文档翻译为Address Space ID)。在进行TLB页表项查找时，TLB页表项的属性字段包含ASID标识，用来指定该页表项属于哪一个进程。MMU从内存中读取页表时，是通过task_struct->mm_struct->pgd查找对应页表项的，即ASID只在TLBs中生效。

## 页表机制

Linux内核使用页表机制管理虚拟内存地址空间，页表保存在内存中，由MMU进行加载和解析。

ARMv8 MMU支持4级页表。

Linux内核支持很多芯片平台，为了统一起见，Linux内核使用3级页表，涉及到每一个具体的芯片平台有自己的页表实现。

页表分为**全局页表和局部页表**，**内核**维护和使用全局页表，每一个进程拥有自己的局部页表。Linux内核为每一个进程维护一个task_struct结构体（即进程描述符），task_struct->mm_struct结构体成员用来保存该进程的局部页表。

Linux进程上下文切换时，内核负责加载当前进程的局部页表，即构建当前进程的虚拟地址空间。

通常来讲，Linux虚拟地址一般分为4个字段：

1. PGD（Page Global Directory）全局页表项

2. PMD（Page Middle Directory）中间页表项

3. PTE（Page Table）页表

4. Offset 偏移地址

二级页表中，PMD通常直接映射到PGD。

## 缺页中段

Linux进程从用户态进入内核态，只有两种方式——系统调用和缺页中断。

Linux系统中使用fork()系统调用（其他操作系统中通常是spawn()函数）创建进程，其实在内核态是由两个系统调用实现的，即clone()和exec()。clone()系统调用负责拷贝父进程的task_struct结构体，exec()系统调用负责创建虚拟地址空间并加载应用程序。

实际上，Linux系统采用著名的写时复制（Copy-On-Write）技术。首先分配好虚拟地址区域，但是并没有实际映射到物理内存，只有在真正要使用时，才分配、映射并读写物理内存。不管是malloc()函数还是ld加载器加载应用程序都是这么实现的。而这一切的基础就是缺页中断。

当Linux进程发起内存访问请求时，发出的是虚拟地址，这个时候MMU就会到TLBs或者内存中加载页表，并查找是否有匹配的页表项。如果没有找到匹配的页表项，则产生缺页中断，由Linux内核分配物理内存，建立新的页表项。

值得一提的是，物理内存通常是有限的，并不能满足所有进程的内存需求。因此，Linux内核引入了swap机制，用来将不频繁使用的页表项对应的物理内存的内容替换到磁盘的swap分区，从而释放物理内存和页表项，用来满足其他进程的需求。Linux内核线程kwapd负责实现swap机制。

嵌入式Linux系统中，往往不支持swap机制，因为嵌入式Linux的物理存储介质通常为Nor Flash或者Nand Flash，其大小一般都远远小于物理内存大小，而且读写速度慢，从各方面看都不能发挥出swap机制的优势。因此，这种情况下，就不得不依赖于Linux内核提供的另外一个杀手进程——Low Memory Killer，一旦系统可用内存低于阈值，则狠心杀掉部分进程，从而释放出物理内存。

Linux内核还提供另外一个工具——OOM (Out of Memory Killer)，通过设置进程的内存阈值，一旦超过阈值则杀死进程以释放内存。即LMK是从整个系统的维度释放物理内存，OOM从进程的维度释放物理内存。

## 空间布局

以32位系统为例，说明Linux进程虚拟地址空间的布局。Linux 32位系统中，虚拟地址空间寻址范围是4GB，分为内核空间和用户空间两部分，以CONFIG_PAGE_OFFSET为界，高1GB为内核空间，低3GB为用户空间。

![](E:\Code\复习心得\res\picture\内存.png)

## 用户空间

　用户空间从低地址到高地址分别为：

　　1）代码段

　　2）数据段（存放全局初始化数据）

　　3）BSS段（存放全局未初始化数据）

　　4）堆（从低地址向高地址增长，通常用于动态内存分配，如malloc函数）

　　5）内存映射段（动态库、libc等基础库映射区）

　　6）栈（进程调用栈，存放局部变量和临时变量）

　　　　进程的栈大小默认为8MB，可以通过ulimit -s设置，一般Linux系统支持栈自动扩展，当栈大小不够时，产生缺页中断，扩展栈大小。

　　　　**线程的栈位于进程的堆中**，因为使用pthread_create()创建线程的时候，实际上是调用malloc()函数在进程的堆中分配一段指定大小（因此线程的栈不能动态增长）的内存用来作为线程的栈。

　　7）环境变量和命令行参数

## 内核空间

![](E:\Code\复习心得\res\picture\内核空间.png)

Linux 32位系统中，内核空间分为直接映射内存段（通常用来做DMA、内核代码段和数据段等），VMALLOC区、持久映射区和高端内存映射区等。但是Linux 64位系统中，这些概念就渐渐模糊了。

　　每一个进程的内核空间的内容是不一样的，Linux进程的进程描述符（task_struct结构体）存放在内核空间的低地址，这是基于安全考虑的，因为用户态可能被篡改。