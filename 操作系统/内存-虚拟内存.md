## 物理内存

早期的计算机上，程序是直接运行在物理内存上的，也是就说，程序运行时访问的是物理地址。这有一个要求，就是程序的内存大小不能超过物理内存大小。但有多个程序时，如何将有限的物理内存分配给多个程序使用就是一个重要的问题。所以这种简单的内存分配策略有很多问题。

1. 地址空间不隔离

   所有程序都是直接访问物理内存，程序使用的空间是不隔离的。如果有其他程序恶意修改，很容易达到破坏的目的，这是程序所不能容忍的。

2. 内存使用效率低

   由于没有有效的内存管理机制，程序在运行过程中，如果想要运行其他程序，就必须将原程序写入磁盘，再将其他程序读到物理内存中，频繁的换入换出，导致效率十分低下。

3. 程序运行的地址不确定

   因为程序每次在装入内存时，都要分配空闲空间，而内存空间时不确定的，所以导致地址不确定。

## 虚拟内存

用户编制程序时使用的地址称为虚地址或逻辑地址，其对应的存储空间称为虚存空间或逻辑地址空间。

1. 每个进程都有各自独立的4G 字节的虚拟地址空间。4G的进程空间分为两部分，0~3G-1 为用户空间，3G~ 4G-1 为内核空间。
2. 用户程序中使用的都是虚拟地址空间中的地址，永远无法直接访问实际物理地址。
3. 虚拟内存到物理内存的映射由操作系统动态维护。
4. 虚拟内存一方面保护了操作系统的安全，另一方面允许应用程序使用比实际物理内存更大的地址空间。
5. 用户空间中的代码不能直接访问内核空间中的代码和数据，但是可以通过系统调用进入内核态，间接地与内核交互。 
6. 对内存的越权访问，或访问未建立映射的虚拟内存（野指针、不在映射表中），将会导致段错误。
7. 用户空间对应进程，进程一切换，用户空间随即变换。
   内核空间由操作系统内核使用，不会随进程切换而变化。
   内核空间由内核根据独立且唯一的页表init_mm.pgd 进行映射，而用户空间的页表则每个进程一份。
8. 每个进程的内存空间完全独立，因此在不同进程之间交换虚拟地址毫无意义。
9. 虚拟内存到物理内存的映射，以页（4096字节）为单位

虚拟储存的实现需要依靠硬件的支持，几乎所有的硬件的都采用叫MMU的部件进行内存映射。

## 物理隔离

为了解决这些问题，提出使用中间层的想法。将程序的地址当作虚拟地址，通过一些映射的方法，将其转为实际的物理地址，这样就可以通过稳定的地址转到实际的物理地址。

### 一、分段

基本思路是将程序需要的内存空间映射到物理空间。假设物理内存100M，如A程序需要10M的空间，就会在物理空间中找一块10M大小的位置，将程序映射到物理空间。若B程序需要90M，就会把剩余的90M给B程序用。这样的思路解决了**地址空间不隔离**和程**序运行的地址不确定**的问题，但是没有解决效率低下的问题，程序的换入换出会造成大量的磁盘写入。为了解决这个问题，提出了粒度更小的内存分割办法，分页。

### 二、分页

分页的基本方法是将地址空间人为的分成固定大小的页。每页大小由系统决定。目前大部分系统的页是4K。物理内存也是同样的办法分割。使程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。
若计算机运行程序或操作所需的随机存储器(RAM)不足时，则 Windows 会用虚拟存储器进行补偿，即拿出一部分硬盘空间来充当内存使用，这部分空间即称为虚拟内存，虚拟内存在硬盘上的存在形式就是 PAGEFILE.SYS这个页面文件。它将计算机的RAM和硬盘上的临时空间组合。将数据移入分页文件可释放RAM，以便完成工作。