

## 一、概念

死锁是指多个线程/进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些线程/进程都将无法向前推进。

## 二、死锁产生的原因

#### 1) 系统资源的竞争

通常系统中拥有的不可剥夺资源，其数量不足以满足多个线程/进程运行的需要，使得线程/进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。

CPU和主存均属于可剥夺性资源，磁带机、打印机等属于不可剥夺性资源。

产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等）

#### 2) 进程推进顺序非法

线程/进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发线程/进程 P1、P2分别保持了资源R1、R2而不释放，而进程P1申请资源R2，进程P2申请资源R1时，两者都会因为所需资源被占用而阻塞。

信号量使用不当也会造成死锁。进程间彼此相互等待对方发来的消息，结果也会使得这些线程/进程间无法继续向前推进。例如，进程A等待进程B发的消息，进程B又在等待进程A 发的消息，**可以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。**

#### 3) 死锁产生的必要条件

产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。

1. 互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。

2. 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。

3. 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
4. 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, ..., pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, ..., n-1)，Pn等待的资源被P0占有

## 三、如何避免线程死锁

#### 破坏条件

1. 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
2. 只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏保持条件）
3. 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
4. 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

## 四、避免死锁

#### 1）加锁顺序

一个线程如果要获取多个锁，必须按照一定的顺序去获取，比如要获取ABC三把锁，我们规定，必须获取到了AB两把锁，才能去获取C锁。

#### 2）加锁时限

一个线程尝试去获取锁，如果在指定的时间内获取不到，就放弃等待锁，并释放自己现在所持有的锁，然后随机等待一定时间，再去获取锁。这里要注意的是 ，等待的时间一定要是随机，不然可能出现 两个线程都释放资源，然后等待相同时间，然后再一起去获取锁，于是又死锁，这种现象称为活锁

#### 3）死锁检测

利用数据结构，如一个map,然后每次线程的上锁，和获取不到锁，都记录在里面，当一个线程获取不到锁的时候，就去遍历查看这个map，看一下有没有死锁，有的话就将整个map里所有的锁全部释放，然后各个线程稍作等待，再去竞争锁。这里还可以优化下，设置优先级，释放所有锁的时候，不释放优先级高的锁，能提高性能。

#### 4）银行家算法

首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。

### 五、死锁的解除

- 抢占资源，从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。
- 终止（或撤销）进程，终止（或撤销）系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来。