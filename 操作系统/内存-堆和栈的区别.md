## 一、管理方式不同

**堆**是由程序员通过调用系统库函数来管理内存，所以管理不力就会出现常说的内存泄漏。

**栈**是由计算机系统分配内存 而且系统有专门的寄存器存储栈指针。

## 二、生长方式不同

**堆是向高地址扩展**也就是常说的向上生长，是**不连续**的内存区域。

**栈是向低地址扩展**也就是常说的向下生长，是**连续**的内存区域。

## 三、空间大小不同

堆的大小可以高达 4G 在32位Linux里系统有效的虚拟内存也有3.2G。堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

栈的大小一般是 1M ~10M 不等（和堆相差很多）大部分是8M。

1. 查看linux默认栈空间的大小
   通过命令 ulimit -s 查看linux的默认栈空间大小，默认情况下为8192 KB 即8MB。
2. 临时改变栈空间的大小
   通过命令 ulimit -s 设置大小值临时改变栈空间大小。例如：ulimit -s 102400，即修改为100MB。
3. 永久修改栈空间大大小。有两种方法：
   方法一：可以在/etc/rc.local 内加入 ulimit -s 102400 则可以开机就设置栈空间大小，任何用户启动的时候都会调用。
   方法二：修改配置文件/etc/security/limits.conf

## 四、内存速率不同

栈的内存速率较快。前面说了栈是系统分配内存 ，而且有这FILO的出栈顺序所以栈的内存速率快些。

堆因为是程序员分配内存，而且是由C/C++函数库提供的。而且机制比较复杂，为了找打到一块合适大小的内存区域会挨个遍历。所以耗时也就比较多些。操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

## 五、存储内容不同

栈在函数调用时，首先压入主调函数中下条指令(函数调用语句的下条可执行语句)的地址，然后是函数实参，然后是被调函数的局部变量。本次调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的指令地址，程序由该点继续运行下条可执行语句。

堆通常在头部用一个字节存放其大小，堆用于存储生存期与函数调用无关的数据，具体内容由程序员安排。

## 六、分配方式不同

栈可静态分配或动态分配。静态分配由编译器完成，如局部变量的分配。动态分配由alloca函数在栈上申请空间，用完后自动释放。

堆只能动态分配且手工释放。(堆就好比OC语言里的MRC，而OC里的ARC就是苹果帮我们处理的MRC)

