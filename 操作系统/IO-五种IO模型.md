# 一、什么是IO

在unix的世界里，一切皆文件。而文件是二进制流。不管是socket还是管道，终端，对我们来说都是文件，在文件操作过程中就是对流进行的操作，都是对流进行数据的收发操作，简称I/O(input and output)操作。计算机里有这么多流，我们通过文件描述符对流进行管理，文件描述符通常用int表示，就是一个fd，对整数的操作就是对流的操作。

IO操作时系统内核态进行的工作，而程序是以用户态运行的，在调用IO操作时会由用户态切换到内核态，耗费一定的时间。

对于一个输入操作来说，进程IO系统调用后，内核会先看缓冲区里有没有数据，没有的话再到设备中读取，因为设备IO一般比较慢，需要等待，内核有数据则直接复制到进程空间。

对于一个网络输入操作通常包含两步：

1. 等待网络数据到达网卡，读取到内核缓冲区；
2. 从内核缓冲区复制数据到用户进程空间

IO通常有内存IO，磁盘IO和网络IO，我们通常说的是后两者

在《Unix网络编程》一书中提到了五种IO模型，分别是：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。

## 一）阻塞IO

用户进程在调用IO操作后，会进入系统调用，内核查看数据，如果数据没有准备好，会一直等待数据准备完毕，这时用户线程处于一个阻塞的状态，用户交出CPU。数据准备完毕后，内核将数据拷贝到用户线程，用户线程才会解锁block（阻塞）状态。

典型的例子： data = socket.read();

## 二）非阻塞IO

在进入系统调用后，如果数据没有准备好，会切到用户态，随后再次调用系统IO，进入系统调用，再次询问内核，数据是否准备完毕，如果没有，周而复始的进行上次活动，直到数据准备完毕。简单来说，就是轮询的一个过程，对于CPU来说消耗比较大。

## 三）多路复用IO

多路复用IO是目前用的比较多的模型，在多路复用IO模型中，会有一个线程不断轮询多个socket端口，只有socket有读写操作时，才会调用实际的IO操作，调用IO资源，减少了系统的资源占用。如select()就是多路复用。

## 四）信号驱动IO

当一个线程发起IO请求时，会注册一个信号函数给Socket，用户线程会继续执行，当内核数据就绪时就会发送一个信号给用户线程。用户在接收到信号后会调用IO进行实际操作。这个一般用于UDP，对于TCP几乎没有，原因是信号产生的过于频繁，而且不知道信号出现时发生了什么。

## 五）异步IO

异步IO是最理想的IO模型，用户在发送一个IO请求之后，可以立刻去做其他的事情，此时内核在接收到请求之后，不会对用户线程进行阻塞，会等待数据准备完成，然后将数据拷贝到用户线程，操作完成之后，内核告诉用户一个信号。用户线程收到信号后就可以直接使用数据。

# 二、IO设计模式

在传统的网络服务设计模式中，有两种比较经典的模式：一种是多线程，一种是线程池。

## 一）多线程

当有一个client请求时，server会创建一个线程，处理client的读写事件，虽然处理方便，但是资源占用比较大。当有新的用户进行连接时，可能会有资源瓶颈，甚至导致服务器崩溃。

## 二）线程池

为了解决一个线程对应一个客户端的模式问题，提出了采用线程池的方式，就是创建固定数量的线程，来一个client，就从线程池取一个空闲线程，客户端处理完读写操作之后，就交出线程，避免每一个client创建线程带来的资源浪费。

但是也有一个弊端，如果是长连接，可能一段时间内，线程池的线程都被占用，无法提供线程进行操作，导致client无法连接。因此线程池适合短连接。

# 三、高性能IO设计模式

在以上模式不能满足需求的情景下，产生了Reactor和Proactor两种高性能的设计模式。

## 一）Reactor

reactor模式适用于同步IO，在Reactor模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询。

**Reactor设计模式中的要素如下：**

1. Handles ：也就是网络连接、文件句柄等，是事件源。
2. Synchronous Event Demultiplexer ：同步事件的解复用（或者说派发），具体的比如 select 调用。比select 更加高效的有Linux下的 epoll ，FreeBSD下的 kqueue 以及Windows下的 iocp （IO Completion port）。
3. Initiation Dispatcher ：注册、移除和分派事件处理器。
4. Event Handler ：事件处理器。

分别以读操作和写操作为例观察Reactor中的具体步骤：

读取操作：

1. 应用程序注册读取事件和相关联的事件处理器。

2. 事件分离器等待事件的发生。

3. 当发生读取事件的时候，事件分离器调用第一步注册的事件处理器。

4. 事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理。

   写入操作类似于读取操作，只不过第一步注册的是写就绪事件。
   

## 二）Proactor

proactor模式适用于异步IO，在Proactor模式中，当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成IO操作之后，发送一个通知告知操作已完成，可以得知，异步IO模型采用的就是Proactor模式

下面我们来看看Proactor模式中读取操作和写入操作的过程：

读取操作：

1. 应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。
2. 事件分离器等待读取操作完成事件。
3. 在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将读取的内容放入用户传递过来的缓存区中。这也是区别于Reactor的一点，Proactor中，应用程序需要传递缓存区。
4. 事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。

Proactor中写入操作和读取操作，只不过感兴趣的事件是写入完成事件。
