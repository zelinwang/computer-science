

很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的。设计模式的六大原则如下。

## 一、单一职责原则（SOLID原则-Single-Responsibility-Principle-SRP）

一个类只负责一个功能领域中相应的职责，就一个类而言，应该只有一个引起它变化的原因。 单一职责原则是实现**高内聚、低耦合**的指导方针。

思想：如果一个类承担的职责过多，就等于把这些职责**耦合**在一起，**一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力**。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。

## 二、开放封闭原则（SOLID 原则-Open Close Principle-OCP）

添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。

比如直观的一个办法就是，通过继承来实现。

ps：华如科技公司的插件机制就是，需要新增功能，就继承插件基类开发新的功能，添加到插件调用列表中。程序运行时即增加了新的功能，原功能也不受影响。

## 三、里式替换原则（SOLID原则-Liskov Substitution Principle-LSP）

一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象之间的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有发生变化。

里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。

里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。

> 里式替换原则对继承进行规范上的约束：
>
> 1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
> 2. 子类中可以增加自己特有的方法。
> 3. 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
> 4. 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

## 四、接口隔离原则（SOLID原则-Interface Segregation Principle-ISP）

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。客户端不应该强迫依赖它不需要的接口。部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思。

从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

## 五、依赖倒置原则（SOLID原则-Dependency Inversion Principle-DIP）

高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。

在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。

#### 1）依赖、倒置原则的作用

1. 依赖倒置原则可以降低类间的耦合性。
2. 依赖倒置原则可以提高系统的稳定性。
3. 依赖倒置原则可以减少并行开发引起的风险。
4. 依赖倒置原则可以提高代码的可读性和可维护性。

#### 2）依赖倒置原则的实现方法

1、依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。
2、每个类尽量提供接口或抽象类，或者两者都具备。
3、变量的声明类型尽量是接口或者是抽象类。
4、任何类都不应该从具体类派生。
5、使用继承时尽量遵循里氏替换原则。

ps：华如的模块编程就是这样。插件开发依赖接口，但是接口的实现没有放在模块中，而是写在了新的实现模块。

## 六、迪米特法则（SOLID原则-Dependency Inversion Principle-DIP）

迪米特法则又叫做最少知道原则。就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。

迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括以下几类：

1. 当前对象本身(this)；

2. 以参数形式传入到当前对象方法中的对象；

3. 当前对象的成员对象；

4. 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；

5. 当前对象所创建的对象。


任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。

> 迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。
>
> 在将迪米特法则运用到系统设计中时，要注意下面的几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。

ps：在金山办公wps的代码中，界面状态改变后，会影响相关的控件或者界面修改。如果直接通过信号和槽调用，不免会有耦合的应用。wps的代码就是使用了一个中间的控件，使得控件行为只传递给了某个中间模块，而中间模块通过一些公共方式来处理。如果控件行为有改变，只需要改变发送/接受控价的代码即可。

**注：开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段 。**
