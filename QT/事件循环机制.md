### 问题1：Qt中常见的事件有哪些？

答：鼠标事件(QMouseEvent)、键盘事件(QKeyEvent)、绘制事件(QPaintEvent)、窗口尺寸改变(QResizeEvent)、滚动事件(QScrollEvent)、控件显示(QShowEvent)、控件隐藏(QHideEvent)、定时器事件(QTimerEvent)等等。。

### 问题2：Qt是事件驱动的，这句话该怎么理解呢？

Qt将系统产生的信号(软件中断)转换成Qt事件，并且将事件封装成类，所有的事件类都是由QEvent派生的，事件的产生和处理就是Qt程序的主轴，且伴随着整个程序的运行周期。因此我们说，Qt是事件驱动的。

### 问题3：Qt事件是由谁产生的？Qt是如何将信号转换成事件的？

答：Qt的官方手册说，事件有两个来源：程序外部和程序内部，多数情况下来自操作系统并且通过spontaneous()函数返回true来获知事件来自于程序外部，当spontaneous()返回false时说明事件来自于程序内部，就像例程1创建一个事件并把它分发出去。

### 问题4：Qt事件是由谁接收的？

答：QObject！它是所有Qt类的基类！是Qt对象模型的核心！QObject类的三大核心功能其中之一就是：事件处理。QObject通过event()函数调用获取事件。
所有的需要处理事件的类都必须继承自Qobject，可以通过重定义event()函数实现自定义事件处理或者将事件交给父类。

### 问题5：事件处理的流程是什么样的？

答：事件有别于信号的重要一点：事件是一个类对象具有特定的类型，事件多数情况下是被分发到一个队列中(事件队列)，当队列中有事件时就不停的将队列中的
事件发送给QObject对象，当队列为空时就阻塞地等待事件，这个过程就是事件循环！

QCoreApplication::exec()开启了这种循环，一直到QCoreApplication::exit()被调用才终止，所以说事件循环是伴随着Qt程序的整个运行周期！另外一种同步处理情形是通过sendEvent()将事件发送出去，直接进入事件的传送和处理流程。postEvent和sendEvent的关系就像Qt::QueuedConnection和Qt::DirectConnection的关系，只不过前两者是分发事件后两者是发送消息罢了，机制上postEvent和QueuedConnected是异步通信，而另外两种是同步通信。

### 问题6：事件过滤器机制？

事件的传送和处理流程的第一站是事件过滤器eventFilter()，某个对象A可以通过给另一个对象B安装事件处理器，实现对对象B事件的监听或者拦截功能。
我们可以给A取名监听器，B取名接收器。一个对象可以监听多个对象，一个对象也可以被多个事件监听。事件过滤器返回true则表示事件已经处理完毕，
否则传递给下一个监听器或者接收器本身。
值得注意的一点是QCoreApplication虽然负责事件分发，但本身也是继承自QObject的，所以在分发事件之前，
也要检查自身是否被别的对象安装了事件过滤器，事件过滤器可能会过滤掉一些事件不发布。 
也可以通过重新实现QCoreApplication的notify()，自定义对事件的处理动作。
小结：事件处理的方式

1.重新实现对象的特定事件处理函数，例如mousePressEvent、keyPressEvent 、showEvent等，处理完毕后将事件交给父类；

2.重新实现event函数，处理完毕后将事件交给父类；

3.在对象上安装事件过滤器，让其他对象控制此对象的事件行为；

4.给主程序QCoreApplication安装事件过滤器，在调用notify进行事件分发之前，会根据过滤器判断对事件的处理（例如：丢弃）；

5.子类化QCoreApplication，重新实现notify事件分发函数；

### 问题7.怎么使用自定义事件？

情景：自定义事件对于特定的操作是很有用的，定义一种连续点击10次鼠标的事件NewMouseEvent,连续点击10次屏幕唤醒屏幕校准程序。

### 问题8：接受者对象中途被删除会发生什么？被监听者被删除会怎么样？

发送失败？程序崩溃? 