STL的sort算法，数据量大时选择快速排序（Quick Sort），分段递归排序。一旦分段后的数据小于某门槛（数据小于16个），为避免快排的递归调用带来的额外负荷，就改用插入排序（Insertion Sort）、如果递归层次过深，还会改用堆排序（Heap Sort）。

快速排序是一种很快的算法，它平均的时间复杂度为O(nlgn)， 最坏时间复杂度为O(n^2)。但是快排有很多改良版，其中一种就是内省式的快排，在STL中的快快排使用的就是这种算法。 

| 排序法 | 平均时间 | 最差情形    | 稳定度 | 额外空间 | 备注                          |
| ------ | -------- | ----------- | ------ | -------- | ----------------------------- |
| 冒泡   | O(n2)    | O(n2)       | 稳定   | O(1)     | n小时较好                     |
| 选择   | O(n2)    | O(n2)       | 不稳定 | O(1)     | n小时较好                     |
| 插入   | O(n2)    | O(n2)       | 稳定   | O(1)     | 大部分已排序时较好            |
| 基数   | O(logRB) | O(logRB)    | 稳定   | O(n)     | B是真数(0-9)，R是基数(个十百) |
| Shell  | O(nlogn) | O(ns) 1<s<2 | 不稳定 | O(1)     | s是所选分组                   |
| 快速   | O(nlogn) | O(n2)       | 不稳定 | O(nlogn) | n大时较好                     |
| 归并   | O(nlogn) | O(nlogn)    | 稳定   | O(1)     | n大时较好                     |
| 堆     | O(nlogn) | O(nlogn)    | 不稳定 | O(1)     | n大时较好                     |

## 一、为什么需要这种算法

因为快排在面对小数组（比如大小为10的数组）且基本有序的情况下，它的表现还没插入排序要好。因为数组的基本有序，使得插入排序不用很多次的执行元素的移动，并且可以避免递归。 在SGI STL中的函数sort使用的排序算法其实就是内省式的排序算法。内省的排序算法是基于快排实现的。假设待排序的数组大小为n，去一个k值，使得k为满足2^k <= n的最大值。k为最大的递归层次、 为什么要设置最大递归层次呢？ 因为快排的递归层次过深的时候，很可能会退化成O(n^2)。内省式排序使用k来控制快排的递归深度，当快排的递归深度到达k的时候选择使用heap排序。 

## 二、为什么不一开始就使用heap排序

heap排序在平均时间复杂度是O(nlgn)，最坏情况也是O(nlgn)，看起来要比快排要快。但是实际上，快排是要比heap排序要快

1. 第一个原因是：heap排序虽然和快排在平均情况下的时间复杂度是O(nlgn)，但是heap排序的时间常数要比快排的时间常数要大。
2. 第二个原因是：据统计，快排的最坏情况在是很少发生的。
3. 第三个原因是：快排能够比较好的吻合程序的空间局部性原理，因为它操作的基本都是相邻的元素（虚拟存储器的设计理论基础中就有程序的时间局部性和空间局部性），能够减少内存缺页中断的发生次数。 

## 三、为什么要使用heap排序呢

因为在递归层次太深的时候，就意味着发生最坏情况的概率大大的提升了，这时候因为heap排序的最坏情况下的时间复杂度是O(nlgn)比快排的O(n^2)要好，因此使用heap排序能更好优化排序效率。

本身比较费时

## 四、list为不能用sort算法

回答：因为sort要求迭代器可以加减除，也就是随机访问迭代器，通俗的讲就是内存连续的容器，而list的内存并不连续。所以不能用全局的sort，但是list自己有sort函数，map也有自己的sort函数