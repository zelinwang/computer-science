

# 仿函数

## 一、原理

仿函数不是函数，是一个行为类似函数的对象。是类或者结构体通过重载operator()操作符来实现，示例如下：

```c++
class FuncClass
{
public:
	void operator()(int val){_val = val;}
	int _val;
};
//--------------------
class FuncStruct
{
public:
	void operator()(int val){_val = val;}
	int _val;
};
FuncClass funC;
funC(5);
FuncStruct funS;
funS(6);
```



## 二、优点

1，拥有状态（state），状态也就是函数对象的数据成员，可以不带痕迹的传递值。
2，拥有其自身的类型。因此可以把仿函数的类型当作template参数来传递，从而指定某种行为的模式。容器的类型也会因为仿函数的不同而不同。
3，执行速度上，仿函数比函数指针更快。仿函数技术可以获得更好的性能，这点直观来讲比较难以理解。你可能说，回调函数申明为inline了，怎么会性能比仿函数差？我们这里来分析下。我们假设某个函数func（例如上面的std::sort）调用中传递了一个回调函数（如上面的compare），那么可以分为两种情况：func是内联函数，并且比较简单，func调用最终被展开了，那么其中对回调函数的调用也成为一普通函数调用（而不是通过函数指针的间接调用），并且如果这个回调函数如果简单，那么也可能同时被展开。在这种情形下，回调函数与仿函数性能相同。
func 是非内联函数，或者比较复杂而无法展开（例如上面的std::sort，我们知道它是快速排序，函数因为存在递归而无法展开）。此时回调函数作为一个函数 指针传入，其代码亦无法展开。而仿函数则不同。虽然func本身复杂不能展开，但是func函数中对仿函数的调用是编译器编译期间就可以确定并进行 inline展开的。因此在这种情形下，仿函数比之于回调函数，有着更好的性能。并且，这种性能优势有时是一种无可比拟的优势（对于std::sort就 是如此，因为元素比较的次数非常巨大，是否可以进行内联展开导致了一种雪崩效应）。

## 三、缺点

话又说回来了，仿函数并不能完全取代回调函数所有的应用场合。例如，我在[std::AutoFreeAlloc](http://www.winxgui.cn/blog/?page_id=41)中使用了回调函数，而不是仿函数，这是因为AutoFreeAlloc要容纳异质的析构函数，而不是只支持某一种类的析构。这和模板（template）不能处理在同一个容器中支持异质类型，是一个道理。